<div fxLayout="column" ngClass.gt-sm="matTypography" ngClass="matTypographySm" fxLayoutGap="16px">
  <div>
    If you've been developing for a "while" like I have (so you also feel old), there's a decent chance that
    you've used <a href="https://jquery.com/">jQuery</a> on the front end (or still use it) and thus have made use of
    <a href="https://datatables.net/">jQuery DataTables</a> (all one word).
    There's also a decent chance that you're moving to newer JavaScript (well, TypeScript, in this case) frameworks 
    such as <a href="https://angular.io/">Angular</a> for your "greenfield" (new code) projects to create SPA (Single Page Applications), 
    which many would agree is the best approach.
  </div>  
  <div>
    So, how would you use Data Tables (two words) in <a href="https://material.angular.io/">Angular Material</a> to create 
    tables that function like <a href="https://benfrog.net/main/exploding.html">these jQuery DataTables</a> on my site?  Let's go through 
    how Angular Material Data Tables works, how it compares to jQuery DataTables, and how to create similar elements with the same data. 
  </div>
  <div>
    To get some "housekeeping" out of the way, all of the examples on my my "old" (it really is old) site use the 
    <a href="https://github.com/datacharmer/test_db">Employees Sample Database</a>, which as I noted there is used on the jQuery DataTables site as well.
    To use that data with this example,  I retrieve it from an <a href="https://github.com/bbutlerfrog/benfrogapi">API</a> I 
    wrote in <a href="https://lumen.laravel.com/"> Laravel Lumen</a>, but obviously you can use any API and database you want to get data into 
    your Angular project.  I'm also going to assume basic knowledge of Angular 7, including 
    <a href="https://angular.io/tutorial/toh-pt6">HttpClient</a>.  I would also highly recommend you take a look at the 
    <a href="https://material.angular.io/cdk/table/api">CDK table documentation</a> on the Angular Material site (which I missed/skipped the first
    time I read the docs due to the fact it's pretty much mentioned as an aside) as I found it pretty vital to get a solid understanding of how 
    exactly Angular Data Tables work and how to customize them.
  </div>
  <div>
    I'm skipping the <a href="https://material.angular.io/components/table/overview#getting-started">"Getting Started"</a> tutorial with a static array, 
    because it's already there, and (as that tutorial mentions), there is virtually no "real world" use for a table built from a static array in the front end.  
    I'm instead going to move on to what amounts to the previous practice of "AJAX-ing in" data, very much
    like <a href="https://datatables.net/reference/option/ajax">this function</a> from jQuery DataTables, which looks like this on the "old site":
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="jsExploding"></code></pre>
  </div>  
  <div>
    I've based this update example largely based upon the "Table retrieving data through HTTP" example 
    <a href="https://material.angular.io/components/table/examples">here</a>, with a large number of "tweaks" because I had the ability to use
    multiple services/classes/interfaces/etc, and my own API. 
  </div>
  <div>
    In that example, there are two simple interfaces, one for the collection of items and a count of those items and another for the items 
    themselves.  This is a solid practice (and as you might guess it's typically best to do the count on the back end if you have control over the API). 
    The only change I made was to break these up into multiple files:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="code1"></code></pre>
    <pre><code [textContent]="code2"></code></pre>
  </div>
  <div>
    As compared to jQuery DataTables, this might seem a bit complicated (and there is a little more work so far), but keep in mind we're getting dynamic table
    content and this is our means of reformatting the JSON into the specific format we need, removing the need to reformat it on the back-end or with
    custom JavaScript.  I had to use this PHP to reformat my previous JSON like 
    <a href="https://github.com/bbutlerfrog/benfrogs-pad/blob/master/main/php/contentServer.php">this</a> for jQuery DataTables.  With more control over each 
    step of building the table, we also gain more flexibility.  For example, I'm going to integrate some 
    of <a href="https://blog.angular-university.io/angular-material-data-table/">this tutorial</a> (note it's for Angular 6,
    but we can still use most of it).  Specifically, the concept of using an observable for our data instead of MatTableDataSource
    <a href="https://material.angular.io/components/table/overview#datasource">(here's why)</a>. Here's a service that provides that Observable:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="departmentService"></code></pre>
  </div>
  <div>
    What we are doing here is providing an Observable that calls the HttpClient's http.get() function, expects a return
    as a "DepartmentApi" object (the array of Department objects and the count of those object), and implements some simple error handling:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="departmentHttp"></code></pre>
  </div>
  <div>
    In the Department Table Component's ngOnInit function (which works much like the oft-used 
    <a href="https://api.jquery.com/ready/">jQuery $(document).ready()</a> function), the constructor 
    requires its own private instance of HttpClient, then passes it along to an instance of  
    the above departmentService, which makes use of it to get our API data (the entire component is 
    <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/department-table/department-table.component.ts">here</a>):
  </div>
  <div highlightChildren class="children" >
    <pre><code [textContent]="departmentTableComponentService"></code></pre>
  </div>
  <div>
    A large amount just happened in a small amount of code, which is a great feature of Angular provided it does not contribute to confusion on the part of 
    the developer.  Let's break it down (and it's also a great idea for this or any other data flow to make use of the excellent stack trace tools we have
    now such as the <a href="https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-firefox-debug">the Visual Studio Code Debugger for Firefox</a> or
    <a href="https://code.visualstudio.com/blogs/2016/02/23/introducing-chrome-debugger-for-vs-code">Chrome</a> to inspect your variables at every stage of 
    this process).  First, we have an (admittedly unnecessary) <a href="https://rxjs-dev.firebaseapp.com/api/index/function/merge">RxJs Merge</a> (we're actually
    merging the <a href="https://material.angular.io/components/sort/api#MatSort">matSortChange</a> event with nothing, but can add events if necessary), then 
    using the RxJS Observable.pipe function (<a href="https://angular.io/guide/rx-library">as documented here</a>).   
  </div>
  <div>
    Step by step, the pipe uses the literally-named 
    <a href="https://rxjs-dev.firebaseapp.com/api/operators/startWith">RxJS StartWith()</a> 
    function to begin with an empty <a href="https://angular.io/guide/observables">observable</a>, then the 
    <a href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap">RxJs switchMap function</a> (there's a deep dive into how 
    switchMap works <a href="https://blog.angular-university.io/rxjs-switchmap-operator/">here</a>) essentially switches around that empty observable
    with the output of departmentsService.getDepartments() when we start to get data from that service.  The map function then removes
    a cosmetic loading flag, sets the resultsLength variable equal to data.length, and finally returns the array of items (a Department[] object).  
    Because we <a href="https://angular.io/guide/observables#subscribing">subscribe</a> to this 
    observable, whenever the department data updates our table will update.  If this sounds familiar, it's likely because it shares that advantage with 
    jQuery AJAX (an observable is actually much more sophisticated and flexible, in that it does not require a direct call to update our table data).    
  </div>
  <div>
    The completed sample table's HTML is <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/department-table/department-table.component.html">
    here</a>.  I've made very few changes from the above examples, and we finally get this (very simple) table:
  <div fxLayout="row wrap" fxLayoutAlign="space-around center">
    <app-department-table></app-department-table> 
  </div>
  <div>
    At this point, anyone could be forgiven for asking if all of that was "worth it", particularly since we still don't have base elements from
    jQuery DataTables such as search and pagination.  Here, however, is where I'd argue the flexibility and power of Angular comes in, and it's 
    both relatively simple to add these elements and they truly can be added nearly anywhere and by nearly any method we'd like.  Let's start by
    mimicking the "default" functionality of jQuery DataTables with a simple "search all" at the top of the table and pagination at the bottom
    (with a more diverse set of data).  We're going to largely use a combination of 
    <a href="https://stackblitz.com/angular/ynlopoomalv?file=app%2Ftable-overview-example.ts">this example</a> and 
    <a href="https://blog.angular-university.io/angular-material-data-table/"> the above-mentioned tutorial</a>, however we are going to use our API data (unlike the first 
    example), are going to modify the tutorial example to use a different means to get our data upon search (largely to show we can) and finally 
    are going to use Angular 7 (the tutorial uses Angular 6, and the largest change is mapping our data return and making use of switchMap in the Observable
    we subscribe to, as in the example above).  
  </div>
  <div>
    First, let's add our search element following largely the <a href="https://blog.angular-university.io/angular-material-data-table/">tutorial's example</a> 
    as example from the <a href="https://material.angular.io/components/table/examples">Angular Material Documentation</a> linked to above "works" without issue,
    but lacks a great deal of flexibility due to the fact that it embeds the keyup() function inside of the HTML:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="employeesMaterialExampleFilter"></code></pre>
  </div>
  <div>
    The approach used in the tutorial is much more flexible and (as mentioned there) allows us to prevent overwhelming our (or another person's) API with a ton of 
    requests on each user keyup/keydown event.  It (and this example) first begins with a native input element:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="employeeTableComponentFilter"></code></pre>
  </div>
  <div>
    Then (after starting with blank content in that filter, shown in the complete component 
    <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/employee-table/employee-table.component.ts">here</a>) we can move
    along to determining if a user "really wants" to search by including an 
    <a href="https://rxjs-dev.firebaseapp.com/api/operators/debounceTime">RxJS debounceTime</a> (which you can of course adjust depending on user experience and
    API rate) and <a href="https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged">RxJS distinctUntilChange</a> (which prevents hits on the API
    when there is no change in the filter criteria):
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="employeeTableComponentFilter"></code></pre>
  </div>
  <div>
    Now whenever the content of the "Search" field changes, it will be passed to the 
    <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/employee.service.ts">employee service's</a> 
    getEmployees function as a parameter, and in turn passed along to the API:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="employeeServiceGetEmployees"></code></pre>
  </div>
  <div>
    You likely noticed that function and service overall are not much different than the 
    <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/departments.service.ts">Departments Service</a> and its getDepartments
    function.  In fact, we've just added a few parameters.  Those of us migrating from 
    <a href="https://datatables.net/manual/server-side">jQuery DataTables Server-Side processing</a> might already spot an advantage: I've used a 
    <a href="https://github.com/bbutlerfrog/benfrogapi/blob/master/app/Http/Controllers/EmployeeController.php">standard and conventional Controller in the
    API</a> that is really not customized for this table at all.  In fact, even if I did not have the ability to customize this API, it would be reasonable
    to expect to pass in a filter and get results.  Server-side jQuery DataTables had and has rather strict requirements for the server-side script, thus
    making it difficult to implement if you lack access to an API, or want to reuse an endpoint for another application.
  </div>
  <div>
    There is also a very solid implementation of pagination in <a href="https://blog.angular-university.io/angular-material-data-table/">that tutorial</a> 
    (with a flexible number of rows per page), and it's not tough at all to 
    add it to our table and make it function largely like the familiar DataTables component.  It depends on resultsLength, which is easily obtained from
    the "count" in the "API" interface.
    First, we'll add a "mat-paginator" element to the bottom of the table:
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="employeeTableHTMLPaginator"></code></pre>
  </div>
  <div>
    Then, back in the 
    <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/employee-table/employee-table.component.ts">employee table component</a>,
    we'll make use of the <a href="https://rxjs-dev.firebaseapp.com/api/index/function/merge">RxJS Merge</a> function to 
    emit the values of a change in the sort parameter and (now) the pagination element (note that we are also resetting pagination to page zero when sorting
    changes):
  </div>
  <div highlightChildren class="children">
    <pre><code [textContent]="employeeTablePaginatorChange"></code></pre>
  </div>
  <div>
    Now whenever the user changes the pagination, filter, or (like the first, very simple table) sort parameter, we make another request to the API for the data.
    This now looks, feels, and functions very much like a jQuery DataTable, as you'll notice:
  </div>
  <div fxLayout="row wrap" fxLayoutAlign="space-around center">
    <app-employee-table></app-employee-table>
  </div>
  <div>
    If you take a look at the <a href="https://github.com/bbutlerfrog/angular-tables/blob/master/src/app/employee-table/employee-table.component.html">
    complete HTML of the table component</a>, you'll note that I've added some other small "tweaks", such as disabling sorting on the two date fields (simply because
    sorting by date is painfully slow on my very small database server).  These changes are very easy, and even fairly large visual and functional modifications 
    aren't difficult, as you'll notice from the complete set of <a href="https://material.angular.io/components/table/examples">examples</a> on the Angular Material
    Documentation page (which is frequently expanded) now that you have a functioning table.  Keep an eye on it and this site for more examples of how to versatile
    Data Tables really can be once you accept the fact DataTables is two words.
  </div>
</div>